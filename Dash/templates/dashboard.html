<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Automation Tests Dashboard</title>
   
    <link rel="icon" 
          type="image/png" 
          href="{{ url_for('static', filename='img/22671') }}">

    <!-- Responsive Meta Tag -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Include Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">

    <!-- Include Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <!-- Link to the Stylesheet -->
    <link rel="stylesheet" href="{{ url_for('static', filename='css/styles.css') }}">

    <!-- Include Font Awesome Icons via CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body aria-label="Automation Dashboard Body" data-theme="light">
    <!-- Navbar -->
    <nav class="navbar" aria-label="Main navigation">
        <div class="navbar-content">
            <div class="navbar-brand">
                <a href="#" title="Go to Dashboard">Automation<span>Dashboard</span></a>
                <!-- Blinking Indicator for repeated failures -->
                <div id="alertIndicator" class="alert-indicator" onclick="showFailedTestsAlert()" style="display: none;">
                    <i class="fas fa-exclamation-triangle"></i>
                </div>
            </div>

            <!-- Two-Button Theme Toggle -->
            <div class="theme-mode-toggle" aria-label="Theme Toggle">
                <button 
                  id="lightModeBtn" 
                  class="toggle-option active" 
                  title="Activate Light Mode"
                >
                    <i class="fas fa-sun"></i>
                    <span>Light Mode</span>
                </button>
                <button 
                  id="darkModeBtn" 
                  class="toggle-option" 
                  title="Activate Dark Mode"
                >
                    <i class="fas fa-moon"></i>
                    <span>Dark Mode</span>
                </button>
            </div>

            <!-- Date/Time element (Easter Egg Trigger) -->
            <div id="currentDateTime" class="current-datetime"></div>
        </div>
    </nav>

    <!-- Header Container -->
    <div class="header-container">
        <h1>Automation Tests Dashboard</h1>
        <p>Your centralized hub for test results and analytics</p>
    </div>

    <!-- Chart Container -->
    <div class="chart-container">
        <div class="chart">
            <h2>Overall Statistics</h2>
            <hr>
            <canvas id="testStatsChart"></canvas>
        </div>
        <div class="chart">
            <h2>Last Hour Statistics</h2>
            <hr>
            <canvas id="lastHourStatsChart"></canvas>
        </div>
        <div class="chart">
            <h2>Most Failed Tests</h2>
            <hr>
            <canvas id="failedTestsChart"></canvas>
        </div>
    </div>

    <!-- Filter and Button Row -->
    <div class="filter-buttons-container">
        <div class="left-section">
            <button class="reset-button" onclick="location.reload();" title="Reset all filters and reload the page">
                <i class="fas fa-sync-alt"></i> Reset Filters
            </button>
            <label for="categoryFilter">Filter by Category:</label>
            <select id="categoryFilter" title="Select a category to filter the tests">
                <option value="all">All</option>
                <option value="qa">QA</option>
                <option value="av">AV</option>
                <option value="cp">CP</option>
            </select>
            <input type="text" id="searchInput" placeholder="Search keyword..." title="Search tests by keyword">

            <!-- Auto-Refresh Dropdown (Persisted in localStorage) -->
            <label for="autoRefreshSelect">Auto-Refresh:</label>
            <select id="autoRefreshSelect" title="Auto-Refresh the page">
                <option value="0">Off</option>
                <option value="5000">5S</option>
                <option value="10000">10S</option>
                <option value="30000">30S</option>
                <option value="60000">1M</option>
            </select>
        </div>

        <!-- Grafana Buttons -->
        <div class="grafana-buttons">
            <a href="https://grafana-main-console.avanan.net/d/d28eee2c-6862-4c30-8111-ea37e99af204/bbd-qa-dashboard?orgId=1&refresh=1m&var-Farm=mt-qa-1&var-Cluster=4" target="_blank">
                <button class="grafana-button" title="Open Grafana QA Dashboard">
                    <i class="fas fa-chart-line"></i> Grafana QA
                </button>
            </a>
            <a href="https://grafana-main-console.avanan.net/d/d28eee2c-6862-4c30-8111-ea37e99af204/bbd-qa-dashboard?orgId=1&refresh=1m" target="_blank">
                <button class="grafana-button" title="Open Grafana Production Dashboard">
                    <i class="fas fa-chart-line"></i> Grafana Production
                </button>
            </a>
            <a href="{{ url_for('bdd_search') }}" target="_blank">
                <button class="bdd-search-button" title="Search the BDD Wiki">
                    <i class="fas fa-search"></i> BDD Wiki
                </button>
            </a>
            <a href="{{ url_for('farm_status') }}" target="_blank">
                <button class="farm-status-button" title="View Farm Status Over Time">
                    <i class="fas fa-chart-line"></i> Farm Status
                </button>
            </a>
        </div>
    </div>

    <!-- 
         Table layout with expansions 
    -->
    <table class="test-summary-table">
        <thead>
            <tr>
                <th>Run Name</th>
                <th>Results Indicators</th>
                <th>Xray</th>
                <th>Time</th>
            </tr>
        </thead>
        <tbody id="testList"></tbody>
    </table>

    <!-- Pagination Container -->
    <div id="paginationControls" class="pagination-controls"></div>

    <!-- Full-page overlay loader -->
    <div id="loaderOverlay" class="loader-overlay" style="display:none;">
        <div class="loader"></div>
    </div>

    <!-- Modal Dialog for Repeated Failures -->
    <div id="failedTestsModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeFailedTestsModal()">&times;</span>
            <h2>Repeated Test Failures</h2>
            <p>The following tests have failed 3 or more times in a row in the last hour:</p>
            <ul id="failedTestsList"></ul>
        </div>
    </div>

    <!-- jQuery -->
    <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>

    <!-- Custom Script -->
    <script>
        /************************************************************
         * 1) Full-page overlay loader (3s minimum)
         ************************************************************/
        let loadStartTime;
        function showLoaderOverlay() {
            loadStartTime = Date.now();
            document.getElementById('loaderOverlay').style.display = 'flex';
        }
        function hideLoaderOverlay() {
            const MINIMUM_LOAD_TIME = 3000;
            const elapsedTime = Date.now() - loadStartTime;
            if (elapsedTime < MINIMUM_LOAD_TIME) {
                setTimeout(() => {
                    document.getElementById('loaderOverlay').style.display = 'none';
                }, MINIMUM_LOAD_TIME - elapsedTime);
            } else {
                document.getElementById('loaderOverlay').style.display = 'none';
            }
        }

        /************************************************************
         * 2) Dark/Light Mode toggles
         ************************************************************/
        function updateChartsForTheme() {
            const theme = document.body.getAttribute('data-theme');
            const textColor = (theme === 'dark') ? '#e0e0e0' : '#212529';

            if (window.testChart && typeof window.testChart.update === 'function') {
                window.testChart.options.plugins.legend.labels.color = textColor;
                window.testChart.options.plugins.tooltip.bodyColor = textColor;
                window.testChart.update();
            }
            if (window.lastHourChart && typeof window.lastHourChart.update === 'function') {
                window.lastHourChart.options.plugins.legend.labels.color = textColor;
                window.lastHourChart.options.plugins.tooltip.bodyColor = textColor;
                window.lastHourChart.update();
            }
            if (window.failedTestsChart && typeof window.failedTestsChart.update === 'function') {
                window.failedTestsChart.options.scales.x.ticks.color = textColor;
                window.failedTestsChart.options.scales.y.ticks.color = textColor;
                window.failedTestsChart.options.plugins.legend.labels.color = textColor;
                window.failedTestsChart.options.plugins.tooltip.bodyColor = textColor;
                window.failedTestsChart.update();
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            const lightModeBtn = document.getElementById('lightModeBtn');
            const darkModeBtn = document.getElementById('darkModeBtn');
            const storedTheme = localStorage.getItem('theme');

            if (storedTheme === 'dark') {
                document.body.setAttribute('data-theme', 'dark');
                darkModeBtn.classList.add('active');
                lightModeBtn.classList.remove('active');
            } else {
                document.body.setAttribute('data-theme', 'light');
                lightModeBtn.classList.add('active');
                darkModeBtn.classList.remove('active');
            }
            updateChartsForTheme();

            lightModeBtn.addEventListener('click', () => {
                document.body.setAttribute('data-theme', 'light');
                localStorage.setItem('theme', 'light');
                lightModeBtn.classList.add('active');
                darkModeBtn.classList.remove('active');
                updateChartsForTheme();
            });

            darkModeBtn.addEventListener('click', () => {
                document.body.setAttribute('data-theme', 'dark');
                localStorage.setItem('theme', 'dark');
                darkModeBtn.classList.add('active');
                lightModeBtn.classList.remove('active');
                updateChartsForTheme();
            });
        });

        /************************************************************
         * 3) Date/time in navbar + Easter Egg
         ************************************************************/
        function updateDateTime() {
            const dateTimeElement = document.getElementById('currentDateTime');
            const now = new Date();
            dateTimeElement.textContent = now.toLocaleString();
        }
        setInterval(updateDateTime, 1000);
        updateDateTime();

        document.addEventListener('DOMContentLoaded', () => {
            const dateTimeElem = document.getElementById('currentDateTime');
            let clickCount = 0;
            let clickTimer = null;
            const SECRET_CODE = "ahz1528";

            dateTimeElem.addEventListener('click', () => {
                clickCount++;
                if (clickTimer) {
                    clearTimeout(clickTimer);
                }
                clickTimer = setTimeout(() => {
                    clickCount = 0;
                }, 2000);

                if (clickCount === 5) {
                    clickCount = 0;
                    clearTimeout(clickTimer);

                    const userInput = prompt("Enter the secret code to download from BDD/Dash/ahz:");
                    if (userInput && userInput === SECRET_CODE) {
                        window.location.href = "/download_bdd_ahz";
                    } else {
                        alert("Invalid code or canceled.");
                    }
                }
            });
        });

        /************************************************************
         * 4) Auto-Refresh logic (persisted in localStorage)
         ************************************************************/
        let autoRefreshTimer = null;
        function setAutoRefresh(interval) {
            if (autoRefreshTimer) {
                clearInterval(autoRefreshTimer);
                autoRefreshTimer = null;
            }
            if (interval > 0) {
                autoRefreshTimer = setInterval(() => {
                    location.reload();
                }, interval);
            }
        }
        document.addEventListener('DOMContentLoaded', () => {
            const savedAutoRefresh = localStorage.getItem('autoRefreshInterval') || '0';
            const autoRefreshSelect = document.getElementById('autoRefreshSelect');
            autoRefreshSelect.value = savedAutoRefresh;
            setAutoRefresh(parseInt(savedAutoRefresh, 10));

            autoRefreshSelect.addEventListener('change', () => {
                const interval = autoRefreshSelect.value;
                localStorage.setItem('autoRefreshInterval', interval);
                setAutoRefresh(parseInt(interval, 10));
            });
        });

        /************************************************************
         * 5) Chart + table helper functions
         ************************************************************/
        function extractFarmName(filename) {
            const parts = filename.split('_AUT-');
            return parts.length > 0 ? parts[0] : 'Unknown';
        }
        function extractJiraTicket(suiteName) {
            const match = suiteName.match(/AUT-\d+/);
            return match ? match[0] : 'Unknown';
        }
        function sanitizeId(id) {
            return id.replace(/[^a-zA-Z0-9_-]/g, '_');
        }

        function create3DGradient(ctx, baseColor) {
            const gradient = ctx.createLinearGradient(0, 0, 0, 300);
            gradient.addColorStop(0, 'rgba(255,255,255,0.7)');
            gradient.addColorStop(0.3, baseColor);
            gradient.addColorStop(1, baseColor);
            return gradient;
        }

        // plugin for center label in doughnut
        const centerLabelPlugin = {
          id: 'centerLabelPlugin',
          afterDraw(chart) {
            if (chart.config.type !== 'doughnut') return;
            const { ctx, chartArea: { left, right, top, bottom } } = chart;
            const theme = document.body.getAttribute('data-theme');
            const labelColor = (theme === 'dark') ? '#ffffff' : '#212529';

            let total = 0;
            chart.data.datasets[0].data.forEach(val => { total += val; });

            ctx.save();
            ctx.font = 'bold 18px Roboto';
            ctx.fillStyle = labelColor;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            const centerX = (left + right) / 2;
            const centerY = (top + bottom) / 2;
            ctx.fillText(String(total), centerX, centerY);
            ctx.restore();
          },
        };

        // RENDER doughnut
        function renderTestStatsChart(passed, failed, broken, skipped, chartId) {
            const ctx = document.getElementById(chartId).getContext('2d');
            const theme = document.body.getAttribute('data-theme');
            const textColor = (theme === 'dark') ? '#e0e0e0' : '#212529';

            const style = getComputedStyle(document.body);
            const passedColor = style.getPropertyValue('--status-passed-color').trim();
            const failedColor = style.getPropertyValue('--status-failed-color').trim();
            const brokenColor = style.getPropertyValue('--status-broken-color').trim();
            const skippedColor = style.getPropertyValue('--status-skipped-color').trim();

            const passedGradient = create3DGradient(ctx, passedColor);
            const failedGradient = create3DGradient(ctx, failedColor);
            const brokenGradient = create3DGradient(ctx, brokenColor);
            const skippedGradient = create3DGradient(ctx, skippedColor);

            const total = passed + failed + broken + skipped;
            const passedPerc = total ? ((passed / total) * 100).toFixed(2) : 0;
            const failedPerc = total ? ((failed / total) * 100).toFixed(2) : 0;
            const brokenPerc = total ? ((broken / total) * 100).toFixed(2) : 0;
            const skippedPerc = total ? ((skipped / total) * 100).toFixed(2) : 0;

            return new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: [
                        `Passed (${passedPerc}%)`,
                        `Failed (${failedPerc}%)`,
                        `Broken (${brokenPerc}%)`,
                        `Skipped (${skippedPerc}%)`
                    ],
                    datasets: [{
                        label: 'Test Results',
                        data: [passed, failed, broken, skipped],
                        backgroundColor: [
                            passedGradient,
                            failedGradient,
                            brokenGradient,
                            skippedGradient
                        ]
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    cutout: '70%',
                    plugins: {
                        legend: {
                            position: 'right',
                            labels: {
                                color: textColor,
                                usePointStyle: true,
                                boxWidth: 10
                            }
                        },
                        tooltip: {
                            bodyColor: textColor,
                            callbacks: {
                                label: function(tooltipItem) {
                                    const count = tooltipItem.parsed;
                                    const pc = total ? ((count / total) * 100).toFixed(2) : 0;
                                    return `${tooltipItem.label}: ${count} (${pc}%)`;
                                }
                            }
                        }
                    }
                },
                plugins: [centerLabelPlugin]
            });
        }

        // RENDER bar
        function renderFailedTestsChart(failedObj, chartId) {
            const ctx = document.getElementById(chartId).getContext('2d');
            const theme = document.body.getAttribute('data-theme');
            const textColor = (theme === 'dark') ? '#e0e0e0' : '#212529';
            const gridColor = (theme === 'dark') ? '#3a3b3c' : '#dee2e6';

            const style = getComputedStyle(document.body);
            const failedColor = style.getPropertyValue('--status-failed-color').trim();

            const sortedFailed = Object.entries(failedObj)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 5);

            const labels = sortedFailed.map(test => test[0]);
            const data = sortedFailed.map(test => test[1]);
            const barGradient = create3DGradient(ctx, failedColor);

            return new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Failed Tests',
                        data: data,
                        backgroundColor: barGradient
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false,
                            labels: { color: textColor }
                        }
                    },
                    scales: {
                        x: {
                            ticks: { color: textColor },
                            grid: { color: gridColor }
                        },
                        y: {
                            beginAtZero: true,
                            ticks: { color: textColor },
                            grid: { color: gridColor }
                        }
                    }
                }
            });
        }

        // update doughnut
        function updateChart(chart, passed, failed, broken, skipped) {
            const total = passed + failed + broken + skipped;
            const passedPerc = total ? ((passed / total) * 100).toFixed(2) : 0;
            const failedPerc = total ? ((failed / total) * 100).toFixed(2) : 0;
            const brokenPerc = total ? ((broken / total) * 100).toFixed(2) : 0;
            const skippedPerc = total ? ((skipped / total) * 100).toFixed(2) : 0;

            chart.data.datasets[0].data = [passed, failed, broken, skipped];
            chart.data.labels = [
                `Passed (${passedPerc}%)`,
                `Failed (${failedPerc}%)`,
                `Broken (${brokenPerc}%)`,
                `Skipped (${skippedPerc}%)`
            ];

            const ctx = chart.ctx;
            const style = getComputedStyle(document.body);
            const passedColor = style.getPropertyValue('--status-passed-color').trim();
            const failedColor = style.getPropertyValue('--status-failed-color').trim();
            const brokenColor = style.getPropertyValue('--status-broken-color').trim();
            const skippedColor = style.getPropertyValue('--status-skipped-color').trim();

            const passedGradient = create3DGradient(ctx, passedColor);
            const failedGradient = create3DGradient(ctx, failedColor);
            const brokenGradient = create3DGradient(ctx, brokenColor);
            const skippedGradient = create3DGradient(ctx, skippedColor);

            chart.data.datasets[0].backgroundColor = [
                passedGradient, failedGradient, brokenGradient, skippedGradient
            ];
            chart.update();
        }

        // update bar
        function updateFailedTestsChart(chart, failedObj) {
            const sortedFailed = Object.entries(failedObj)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 5);

            const labels = sortedFailed.map(test => test[0]);
            const data = sortedFailed.map(test => test[1]);

            chart.data.datasets[0].data = data;
            chart.data.labels = labels;

            const ctx = chart.ctx;
            const style = getComputedStyle(document.body);
            const failedColor = style.getPropertyValue('--status-failed-color').trim();
            const barGradient = create3DGradient(ctx, failedColor);

            chart.data.datasets[0].backgroundColor = barGradient;
            chart.update();
        }

        function getStatusIndicators(tests) {
            return tests.map(test => {
                if (test.status === 'passed') {
                    return `<span class="status-indicator status-passed" title="Test Passed"></span>`;
                } else if (test.status === 'failed') {
                    return `<span class="status-indicator status-failed" title="Test Failed"></span>`;
                } else if (test.status === 'broken') {
                    return `<span class="status-indicator status-broken" title="Test Broken"></span>`;
                } else if (test.status === 'skipped') {
                    return `<span class="status-indicator status-skipped" title="Test Skipped"></span>`;
                } else {
                    return `<span class="status-indicator" title="Unknown"></span>`;
                }
            }).join('');
        }

        function formatTimestamp(timestamp) {
            const date = new Date(timestamp * 1000);
            return date.toLocaleString();
        }

        /************************************************************
         * 6) DOMContentLoaded => Show loader => fetch => hide
         ************************************************************/
        document.addEventListener('DOMContentLoaded', function() {
            showLoaderOverlay();
            window.addEventListener('load', hideLoaderOverlay);

            fetch('{{ url_for("static", filename="data.json") }}')
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok');
                    }
                    return response.json();
                })
                .then(data => {
                    const testList = document.getElementById('testList');
                    window.files = {};
                    const oneHourAgo = Date.now() - 3600 * 1000;

                    let failedTestsAlert = [];
                    const testFailures = {};

                    let passedCount = 0;
                    let failedCount = 0;
                    let brokenCount = 0;
                    let skippedCount = 0;

                    let lastHourPassedCount = 0;
                    let lastHourFailedCount = 0;
                    let lastHourBrokenCount = 0;
                    let lastHourSkippedCount = 0;

                    window.failedTests = {};

                    // Process data
                    for (const [dirName, tests] of Object.entries(data)) {
                        tests.forEach(test => {
                            const filename = test.filename;
                            const testName = test.name;
                            const testTime = new Date(test.start_time).getTime();
                            const testStatus = test.status;
                            const farmName = extractFarmName(filename);

                            if (!window.files[filename]) {
                                window.files[filename] = {
                                    tests: [],
                                    categories: new Set(),
                                    timestamp: parseInt(filename.split('_').pop())
                                };
                            }
                            window.files[filename].tests.push(test);
                            window.files[filename].categories.add(test.category);

                            if (testStatus === 'passed') {
                                passedCount++;
                            } else if (testStatus === 'failed') {
                                failedCount++;
                                if (!window.failedTests[testName]) {
                                    window.failedTests[testName] = 0;
                                }
                                window.failedTests[testName]++;
                            } else if (testStatus === 'broken') {
                                brokenCount++;
                            } else if (testStatus === 'skipped') {
                                skippedCount++;
                            }

                            if (testTime > oneHourAgo) {
                                if (testStatus === 'passed') {
                                    lastHourPassedCount++;
                                } else if (testStatus === 'failed') {
                                    lastHourFailedCount++;
                                } else if (testStatus === 'broken') {
                                    lastHourBrokenCount++;
                                } else if (testStatus === 'skipped') {
                                    lastHourSkippedCount++;
                                }
                                if (testStatus === 'failed') {
                                    if (!testFailures[testName]) {
                                        testFailures[testName] = [];
                                    }
                                    testFailures[testName].push({
                                        status: testStatus,
                                        time: testTime,
                                        farm: farmName
                                    });
                                }
                            }
                        });
                    }

                    // Identify tests with 3+ consecutive failures
                    for (const [testName, testRuns] of Object.entries(testFailures)) {
                        let consecutiveFailuresCount = 0;
                        let lastFarm = 'Unknown';
                        testRuns.sort((a, b) => b.time - a.time);

                        for (const run of testRuns) {
                            if (run.status === 'failed') {
                                consecutiveFailuresCount++;
                                lastFarm = run.farm;
                                if (consecutiveFailuresCount >= 3) {
                                    failedTestsAlert.push({
                                        testName: testName,
                                        farmName: lastFarm,
                                        count: consecutiveFailuresCount
                                    });
                                    break;
                                }
                            } else {
                                break; 
                            }
                        }
                    }

                    if (failedTestsAlert.length > 0) {
                        const alertIndicator = document.getElementById('alertIndicator');
                        alertIndicator.style.display = 'inline-block';
                        window.failedTestsAlert = failedTestsAlert;
                    }

                    // Render charts
                    window.testChart = renderTestStatsChart(
                      passedCount, failedCount, brokenCount, skippedCount, 'testStatsChart'
                    );
                    window.lastHourChart = renderTestStatsChart(
                      lastHourPassedCount, lastHourFailedCount,
                      lastHourBrokenCount, lastHourSkippedCount, 'lastHourStatsChart'
                    );
                    window.failedTestsChart = renderFailedTestsChart(window.failedTests, 'failedTestsChart');

                    const itemsPerPage = 25;
                    let currentPage = 1;

                    function renderList() {
                        testList.innerHTML = '';
                        const categoryFilter = document.getElementById('categoryFilter').value;
                        const searchKeyword = document.getElementById('searchInput').value.toLowerCase();

                        let filteredPassedCount = 0;
                        let filteredFailedCount = 0;
                        let filteredBrokenCount = 0;
                        let filteredSkippedCount = 0;

                        let filteredLastHourPassedCount = 0;
                        let filteredLastHourFailedCount = 0;
                        let filteredLastHourBrokenCount = 0;
                        let filteredLastHourSkippedCount = 0;

                        let filteredFailedTests = {};

                        const sortedFiles = Object.keys(window.files).sort(
                          (a, b) => window.files[b].timestamp - window.files[a].timestamp
                        );

                        // Filter the files
                        const fileNames = sortedFiles.filter(filename => {
                            const fileObj = window.files[filename];

                            // Filter by Category
                            if (categoryFilter !== 'all') {
                                if (!fileObj.categories.has(categoryFilter)) {
                                    return false;
                                }
                            }

                            // Filter by search keyword (any test name or filename)
                            if (searchKeyword) {
                                let matched = false;
                                for (const t of fileObj.tests) {
                                    if (t.name.toLowerCase().includes(searchKeyword)) {
                                        matched = true;
                                        break;
                                    }
                                }
                                const fileNameMatches = filename.toLowerCase().includes(searchKeyword);
                                if (!matched && !fileNameMatches) {
                                    return false;
                                }
                            }
                            return true;
                        });

                        // Count status for these filtered files
                        fileNames.forEach(filename => {
                            const tests = window.files[filename].tests;
                            tests.forEach(test => {
                                const testTime = new Date(test.start_time).getTime();
                                const status = test.status;
                                const testName = test.name;

                                if (status === 'passed') {
                                    filteredPassedCount++;
                                    if (testTime > oneHourAgo) {
                                        filteredLastHourPassedCount++;
                                    }
                                } else if (status === 'failed') {
                                    filteredFailedCount++;
                                    if (testTime > oneHourAgo) {
                                        filteredLastHourFailedCount++;
                                    }
                                    if (!filteredFailedTests[testName]) {
                                        filteredFailedTests[testName] = 0;
                                    }
                                    filteredFailedTests[testName]++;
                                } else if (status === 'broken') {
                                    filteredBrokenCount++;
                                    if (testTime > oneHourAgo) {
                                        filteredLastHourBrokenCount++;
                                    }
                                } else if (status === 'skipped') {
                                    filteredSkippedCount++;
                                    if (testTime > oneHourAgo) {
                                        filteredLastHourSkippedCount++;
                                    }
                                }
                            });
                        });

                        // Build the table rows for the current page
                        const startIndex = (currentPage - 1) * itemsPerPage;
                        const endIndex = startIndex + itemsPerPage;
                        const pageFiles = fileNames.slice(startIndex, endIndex);

                        pageFiles.forEach(filename => {
                            const baseName = filename.replace('.html', '');
                            const timestamp = window.files[filename].timestamp;
                            const readableTimestamp = formatTimestamp(timestamp);
                            const sanitizedFilename = sanitizeId(filename);

                            // SUMMARY row
                            const summaryRow = document.createElement('tr');
                            summaryRow.style.cursor = 'pointer';
                            summaryRow.innerHTML = `
                                <td class="file-name" title="${baseName}">${baseName}</td>
                                <td>
                                  <div class="status-indicators">
                                    ${getStatusIndicators(window.files[filename].tests)}
                                  </div>
                                </td>
                                <td>
                                  <a href="https://avanan.atlassian.net/browse/${extractJiraTicket(baseName)}"
                                     target="_blank" class="jira-button"
                                     title="Open Jira Ticket">
                                     <i class="fab fa-jira"></i> Jira
                                  </a>
                                </td>
                                <td class="timestamp" title="Test Timestamp">
                                  ${readableTimestamp}
                                </td>
                            `;

                            // DETAIL row
                            const detailRow = document.createElement('tr');
                            detailRow.id = `details-${sanitizedFilename}`;
                            detailRow.style.display = 'none';
                            detailRow.innerHTML = `
                                <td colspan="4" class="details-cell">
                                    <p>Loading data...</p>
                                </td>
                            `;

                            summaryRow.onclick = () => {
                                toggleRowExpansion(sanitizedFilename, filename);
                            };

                            testList.appendChild(summaryRow);
                            testList.appendChild(detailRow);
                        });

                        // Update charts
                        updateChart(window.testChart,
                          filteredPassedCount, filteredFailedCount,
                          filteredBrokenCount, filteredSkippedCount
                        );
                        updateChart(window.lastHourChart,
                          filteredLastHourPassedCount, filteredLastHourFailedCount,
                          filteredLastHourBrokenCount, filteredLastHourSkippedCount
                        );
                        updateFailedTestsChart(window.failedTestsChart, filteredFailedTests);

                        // Render pagination
                        renderPaginationButtons(fileNames.length);
                    }

                    renderList();

                    document.getElementById('categoryFilter').addEventListener('change', function() {
                        currentPage = 1;
                        renderList();
                    });
                    document.getElementById('searchInput').addEventListener('input', function() {
                        currentPage = 1;
                        renderList();
                    });

                    // Pagination function
                    function renderPaginationButtons(totalFiles) {
                        const paginationControls = document.getElementById('paginationControls');
                        if (!paginationControls) return;

                        paginationControls.innerHTML = '';

                        const totalPages = Math.ceil(totalFiles / itemsPerPage);
                        const visiblePages = 10;
                        const startPage = Math.max(
                            1,
                            Math.min(currentPage - Math.floor(visiblePages / 2), totalPages - visiblePages + 1)
                        );
                        const endPage = Math.min(totalPages, startPage + visiblePages - 1);

                        const paginationList = document.createElement('ul');
                        paginationList.className = 'pagination';

                        const firstButton = document.createElement('li');
                        firstButton.textContent = 'First';
                        firstButton.onclick = () => {
                            currentPage = 1;
                            renderList();
                        };
                        paginationList.appendChild(firstButton);

                        const prevButton = document.createElement('li');
                        prevButton.textContent = 'Prev';
                        prevButton.onclick = () => {
                            currentPage = Math.max(currentPage - 1, 1);
                            renderList();
                        };
                        paginationList.appendChild(prevButton);

                        for (let i = startPage; i <= endPage; i++) {
                            const pageButton = document.createElement('li');
                            pageButton.textContent = i;
                            if (i === currentPage) {
                                pageButton.className = 'active';
                            }
                            pageButton.onclick = () => {
                                currentPage = i;
                                renderList();
                            };
                            paginationList.appendChild(pageButton);
                        }

                        const nextButton = document.createElement('li');
                        nextButton.textContent = 'Next';
                        nextButton.onclick = () => {
                            currentPage = Math.min(currentPage + 1, totalPages);
                            renderList();
                        };
                        paginationList.appendChild(nextButton);

                        const lastButton = document.createElement('li');
                        lastButton.textContent = 'Last';
                        lastButton.onclick = () => {
                            currentPage = totalPages;
                            renderList();
                        };
                        paginationList.appendChild(lastButton);

                        paginationControls.appendChild(paginationList);
                    }
                })
                .catch(error => {
                    console.error('Error fetching data:', error);
                    document.getElementById('loaderOverlay').style.display = 'none';
                });
        });

        // Toggle expansions
        function toggleRowExpansion(sanitizedFilename, filename) {
            const detailRow = document.getElementById('details-' + sanitizedFilename);
            if (!detailRow) return;

            if (detailRow.style.display === 'none' || detailRow.style.display === '') {
                detailRow.style.display = 'table-row';
                if (!detailRow.dataset.loaded) {
                    renderTestTable(filename, sanitizedFilename);
                    detailRow.dataset.loaded = 'true';
                }
            } else {
                detailRow.style.display = 'none';
            }
        }

        function renderTestTable(filename, sanitizedFilename) {
            const detailRow = document.getElementById('details-' + sanitizedFilename);
            if (!detailRow) return;

            const cell = detailRow.querySelector('.details-cell');
            if (!cell) return;

            const tests = window.files[filename].tests || [];

            let html = `<p>Detailed data for <strong>${filename}</strong>:</p>`;
            html += `<table class="test-table">
                        <thead>
                            <tr class="static-header">
                                <th>Test Name</th>
                                <th>Status</th>
                                <th>Start Time</th>
                                <th>Duration</th>
                                <th>Allure Stats</th>
                            </tr>
                        </thead>
                        <tbody>
            `;

            for (const t of tests) {
                let statusClass = '';
                if (t.status === 'passed') {
                    statusClass = 'status-passed-row highlight-row';
                } else if (t.status === 'failed') {
                    statusClass = 'status-failed-row highlight-row';
                } else if (t.status === 'broken') {
                    statusClass = 'status-broken-row highlight-row';
                } else if (t.status === 'skipped') {
                    statusClass = 'status-skipped-row highlight-row';
                }
                const startTime = new Date(t.start_time).toLocaleString();
                const duration = t.duration + ' ms';

                html += `
                    <tr class="${statusClass}">
                        <td>${t.name}</td>
                        <td>${t.status}</td>
                        <td>${startTime}</td>
                        <td>${duration}</td>
                        <td>
                            <a href="/download/${filename}" target="_blank" 
                               title="View Allure Report">
                               View Report
                            </a>
                        </td>
                    </tr>
                `;
            }
            html += `</tbody></table>`;
            cell.innerHTML = html;
        }

        // Modal repeated failures
        function showFailedTestsAlert() {
            const modal = document.getElementById('failedTestsModal');
            const failedTestsList = document.getElementById('failedTestsList');
            failedTestsList.innerHTML = '';

            if (window.failedTestsAlert) {
                window.failedTestsAlert.forEach(test => {
                    const listItem = document.createElement('li');
                    listItem.textContent = `${test.testName} failed ${test.count} times in a row in ${test.farmName}`;
                    failedTestsList.appendChild(listItem);
                });
            }
            modal.style.display = 'block';
        }
        function closeFailedTestsModal() {
            const modal = document.getElementById('failedTestsModal');
            modal.style.display = 'none';
        }
        window.onclick = function(event) {
            const modal = document.getElementById('failedTestsModal');
            if (event.target === modal) {
                modal.style.display = 'none';
            }
        };
    </script>

    <!-- Footer -->
    <footer class="signature">
        <p>&copy; 2025 Automation Team. All rights reserved.</p>
    </footer>
</body>
</html>
