<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Automation Tests Dashboard</title>
   
    <!-- Favicon -->
    <link
        rel="icon"
        type="image/png"
        href="{{ url_for('static', filename='img/22671') }}"
    >

    <!-- Responsive Meta Tag -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Google Fonts -->
    <link
        href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap"
        rel="stylesheet"
    >

    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <!-- Font Awesome Icons -->
    <link
        rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    >

    <!-- Your main CSS file (MUST include side menu + push rules) -->
    <link
        rel="stylesheet"
        href="{{ url_for('static', filename='css/styles.css') }}"
    >

    <!-- jsPDF (UMD) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

    <!-- jsPDF AutoTable plugin -->
    <script src="https://cdn.jsdelivr.net/npm/jspdf-autotable/dist/jspdf.plugin.autotable.min.js"></script>

</head>

<body aria-label="Automation Dashboard Body" data-theme="light">
    <!-- SIDE MENU (Push style) -->
    <div id="sideMenu" class="side-menu">
        <!-- Close button -->
        <button class="close-side-menu" onclick="closeSideMenu()">&times;</button>

        <h3>Menu</h3>
        <hr>

        <!-- Export Data Section -->
        <div style="margin-bottom: 12px;">
            <h4>Export Data</h4>
            <!-- Instead of directly calling export*, we call promptExport* -->
            <button onclick="promptExportCSV()">Export CSV</button>
            <button onclick="promptExportPDF()">Export PDF</button>
        </div>
        <!-- Add any more side menu items here as needed -->
    </div>

    <!-- MAIN CONTENT WRAPPER -->
    <div class="main-content">
        <!-- Navbar -->
        <nav class="navbar" aria-label="Main navigation">
            <div class="navbar-content">
                <div class="navbar-brand">
                    <!-- Hamburger Button to Open Side Menu -->
                    <button
                      class="menu-toggle"
                      onclick="openSideMenu()"
                      title="Open Side Menu"
                      style="background: none; border: none; cursor: pointer; margin-right: 12px;"
                    >
                        <i class="fas fa-bars" style="font-size: 22px;"></i>
                    </button>

                    <a href="#" title="Go to Dashboard">Automation<span>Dashboard</span></a>
                    <!-- Blinking Indicator for repeated failures -->
                    <div
                        id="alertIndicator"
                        class="alert-indicator"
                        onclick="showFailedTestsAlert()"
                        style="display: none;"
                    >
                        <i class="fas fa-exclamation-triangle"></i>
                    </div>
                </div>

                <!-- Two-Button Theme Toggle -->
                <div class="theme-mode-toggle" aria-label="Theme Toggle">
                    <button
                      id="lightModeBtn"
                      class="toggle-option active"
                      title="Activate Light Mode"
                    >
                        <i class="fas fa-sun"></i>
                        <span>Light Mode</span>
                    </button>
                    <button
                      id="darkModeBtn"
                      class="toggle-option"
                      title="Activate Dark Mode"
                    >
                        <i class="fas fa-moon"></i>
                        <span>Dark Mode</span>
                    </button>
                </div>

                <!-- Date/Time element (Easter Egg Trigger) -->
                <div id="currentDateTime" class="current-datetime"></div>
            </div>
        </nav>

        <!-- Header Container -->
        <div class="header-container">
            <h1>Automation Tests Dashboard</h1>
            <p>Your centralized hub for test results and analytics</p>
        </div>

        <!-- Chart Container -->
        <div class="chart-container">
            <div class="chart">
                <h2>Overall Statistics</h2>
                <hr>
                <canvas id="testStatsChart"></canvas>
            </div>
            <div class="chart">
                <h2>Last Hour Statistics</h2>
                <hr>
                <canvas id="lastHourStatsChart"></canvas>
            </div>
            <div class="chart">
                <h2>Most Failed Tests</h2>
                <hr>
                <canvas id="failedTestsChart"></canvas>
            </div>
        </div>

        <!-- Filter and Button Row -->
        <div class="filter-buttons-container">
            <div class="left-section">
                <button
                    class="reset-button"
                    onclick="location.reload();"
                    title="Reset all filters and reload the page"
                >
                    <i class="fas fa-sync-alt"></i> Reset Filters
                </button>
                <label for="categoryFilter">Filter by Category:</label>
                <select
                    id="categoryFilter"
                    title="Select a category to filter the tests"
                >
                    <option value="all">All</option>
                    <option value="qa">QA</option>
                    <option value="av">AV</option>
                    <option value="cp">CP</option>
                </select>

                <!-- NEW: Farm Dropdown -->
                <label for="farmFilter">Filter by Farm:</label>
                <select
                    id="farmFilter"
                    title="Select a farm to filter the tests"
                >
                    <option value="all">All</option>
                </select>

                <!-- NEW: Cluster Dropdown -->
                <label for="clusterFilter">Filter by Cluster:</label>
                <select
                    id="clusterFilter"
                    title="Select a cluster to filter the tests"
                >
                    <option value="all">All</option>
                </select>

                <input
                    type="text"
                    id="searchInput"
                    placeholder="Search keyword..."
                    title="Search tests by keyword"
                >

                <!-- Auto-Refresh Dropdown (Persisted in localStorage) -->
                <label for="autoRefreshSelect">Auto-Refresh:</label>
                <select
                    id="autoRefreshSelect"
                    title="Auto-Refresh the page"
                >
                    <option value="0">Off</option>
                    <option value="5000">5S</option>
                    <option value="10000">10S</option>
                    <option value="30000">30S</option>
                    <option value="60000">1M</option>
                </select>
            </div>

            <!-- Grafana Buttons -->
            <div class="grafana-buttons">
                <a
                    href="https://grafana-main-console.avanan.net/d/d28eee2c-6862-4c30-8111-ea37e99af204/bbd-qa-dashboard?orgId=1&refresh=1m&var-Farm=mt-qa-1&var-Cluster=4"
                    target="_blank"
                >
                    <button class="grafana-button" title="Open Grafana QA Dashboard">
                        <i class="fas fa-chart-line"></i> Grafana QA
                    </button>
                </a>
                <a
                    href="https://grafana-main-console.avanan.net/d/d28eee2c-6862-4c30-8111-ea37e99af204/bbd-qa-dashboard?orgId=1&refresh=1m"
                    target="_blank"
                >
                    <button class="grafana-button" title="Open Grafana Production Dashboard">
                        <i class="fas fa-chart-line"></i> Grafana Production
                    </button>
                </a>
                <a
                    href="{{ url_for('bdd_search') }}"
                    target="_blank"
                >
                    <button class="bdd-search-button" title="Search the BDD Wiki">
                        <i class="fas fa-search"></i> BDD Wiki
                    </button>
                </a>
                <a
                    href="{{ url_for('farm_status') }}"
                    target="_blank"
                >
                    <button class="farm-status-button" title="View Farm Status Over Time">
                        <i class="fas fa-chart-line"></i> Farm Status
                    </button>
                </a>
            </div>
        </div>

        <!-- Table layout with expansions -->
        <table class="test-summary-table">
            <thead>
                <tr>
                    <th>Run Name</th>
                    <th>Results Indicators</th>
                    <th>Xray</th>
                    <th>Time</th>
                </tr>
            </thead>
            <tbody id="testList"></tbody>
        </table>

        <!-- Pagination Container -->
        <div id="paginationControls" class="pagination-controls"></div>

        <!-- Full-page overlay loader -->
        <div id="loaderOverlay" class="loader-overlay" style="display:none;">
            <div class="loader"></div>
        </div>

        <!-- Modal Dialog for Repeated Failures -->
        <div id="failedTestsModal" class="modal">
            <div class="modal-content">
                <span class="close-button" onclick="closeFailedTestsModal()">&times;</span>
                <h2>Repeated Test Failures</h2>
                <p>The following tests have failed 3 or more times in a row in the last hour:</p>
                <ul id="failedTestsList"></ul>
            </div>
        </div>
    </div>  <!-- END .main-content -->

    <!-- jQuery -->
    <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>

    <!-- Main Inline Script -->
    <script>
        /****************************************************************
         * 1) Side Menu "Push" Logic
         ****************************************************************/
        function openSideMenu() {
            document.getElementById('sideMenu').classList.add('open');
            document.body.classList.add('menu-open'); // pushes .main-content right
        }
        function closeSideMenu() {
            document.getElementById('sideMenu').classList.remove('open');
            document.body.classList.remove('menu-open');
        }

        /****************************************************************
         * 2) Prompt user for "all" or # of pages, then call export
         ****************************************************************/
        function promptExportCSV() {
            let response = prompt("Enter a number of pages to export or 'all' for everything:");
            if (!response) return; // user canceled
            response = response.trim().toLowerCase();
            exportTableToCSV(response);
        }
        function promptExportPDF() {
            let response = prompt("Enter a number of pages to export or 'all' for everything:");
            if (!response) return;
            response = response.trim().toLowerCase();
            exportTableToPDF(response);
        }

        /****************************************************************
         * 3) Gather Data from window.files with pagination or all
         ****************************************************************/
        function gatherExportData(pageRequest) {
            // "pageRequest" is either "all" or a string representing #pages
            // We will gather data from window.files, replicating the sorting & filtering logic

            const dataRows = [];
            // get current filter settings => to respect user category & search filters
            const categoryFilter = document.getElementById('categoryFilter').value;
            const farmFilter = document.getElementById('farmFilter') ? document.getElementById('farmFilter').value : 'all';
            const clusterFilter = document.getElementById('clusterFilter') ? document.getElementById('clusterFilter').value : 'all';
            const searchKeyword = document.getElementById('searchInput').value.toLowerCase();

            const oneHourAgo = Date.now() - 3600 * 1000;
            const sortedFiles = Object.keys(window.files).sort(
                (a, b) => window.files[b].timestamp - window.files[a].timestamp
            );

            // filter out files not matching user filters / search
            const fileNames = sortedFiles.filter(filename => {
                const fileObj = window.files[filename];

                // Category filter
                if (categoryFilter !== 'all') {
                    if (!fileObj.categories.has(categoryFilter)) return false;
                }
                // Farm filter
                if (farmFilter !== 'all') {
                    // check if any test in that file has this farm
                    let hasFarm = false;
                    for (const t of fileObj.tests) {
                        if (t.farm === farmFilter) {
                            hasFarm = true;
                            break;
                        }
                    }
                    if (!hasFarm) return false;
                }
                // Cluster filter
                if (clusterFilter !== 'all') {
                    let hasCluster = false;
                    for (const t of fileObj.tests) {
                        if (t.cluster === clusterFilter) {
                            hasCluster = true;
                            break;
                        }
                    }
                    if (!hasCluster) return false;
                }
                // search keyword
                if (searchKeyword) {
                    let matched = false;
                    for (const t of fileObj.tests) {
                        if (t.name.toLowerCase().includes(searchKeyword)) {
                            matched = true;
                            break;
                        }
                    }
                    const fileNameMatches = filename.toLowerCase().includes(searchKeyword);
                    if (!matched && !fileNameMatches) return false;
                }
                return true;
            });

            // how many items per page?
            const itemsPerPage = 25;
            // how many total pages?
            const totalPages = Math.ceil(fileNames.length / itemsPerPage);

            let requestedPages = 1;
            if (pageRequest === 'all') {
                requestedPages = totalPages;
            } else {
                const num = parseInt(pageRequest, 10);
                if (isNaN(num) || num < 1) {
                    requestedPages = 1;  // fallback if user typed something invalid
                } else {
                    requestedPages = Math.min(num, totalPages);
                }
            }

            // gather data from "page 1" up to "requestedPages"
            for (let currentPage = 1; currentPage <= requestedPages; currentPage++) {
                const startIndex = (currentPage - 1) * itemsPerPage;
                const endIndex = startIndex + itemsPerPage;
                const pageFiles = fileNames.slice(startIndex, endIndex);

                pageFiles.forEach(filename => {
                    const baseName = filename.replace('.html', '');
                    const tests = window.files[filename].tests;

                    // Build "Results Indicators" => parse the tests
                    let spans = [];
                    for (const t of tests) {
                        if (t.status === 'passed') spans.push('V');
                        else if (t.status === 'failed') spans.push('X');
                        else if (t.status === 'broken') spans.push('B');
                        else if (t.status === 'skipped') spans.push('S');
                    }
                    const resultsString = spans.join(',');

                    // Xray link
                    const jiraTicket = extractJiraTicket(baseName);
                    const xrayLink = `https://avanan.atlassian.net/browse/${jiraTicket}`;

                    // Time
                    const timestamp = window.files[filename].timestamp;
                    const readableTimestamp = formatTimestamp(timestamp);

                    // push row => [Run Name, Results, Xray Link, Time]
                    dataRows.push([ baseName, resultsString, xrayLink, readableTimestamp ]);
                });
            }
            return dataRows;
        }

        /****************************************************************
         * 4) Updated Export CSV / PDF using gatherExportData()
         ****************************************************************/
        function exportTableToCSV(pageRequest) {
            // gather all relevant data
            const tableData = gatherExportData(pageRequest);
            let csvContent = "data:text/csv;charset=utf-8,";

            // CSV headers
            const headers = ["Run Name", "Results Indicators", "Xray", "Time"];
            csvContent += headers.join(",") + "\n";

            tableData.forEach(row => {
                // row is [runName, resultsString, xrayLink, timeVal]
                csvContent += row
                    .map(v => `"${v.replace(/"/g, '""')}"`)
                    .join(",") + "\n";
            });

            // create download link
            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", "dashboard_data.csv");
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function exportTableToPDF(pageRequest) {
            // gather all relevant data
            const tableData = gatherExportData(pageRequest);

            const { jsPDF } = window.jspdf;
            const doc = new jsPDF({ orientation: 'l', unit: 'pt', format: 'a4' });
            doc.setFont("helvetica", "bold");
            doc.setFontSize(14);
            doc.text("Automation Dashboard Export", 40, 40);

            // autoTable
            const headers = [["Run Name", "Results", "Xray", "Time"]];
            doc.autoTable({
                startY: 60,
                head: headers,
                body: tableData,
                styles: { font: "helvetica", fontSize: 10, cellPadding: 4 },
                headStyles: { fillColor: [52, 58, 64], textColor: 255 },
                margin: { left: 40, right: 40 },
                theme: 'grid'
            });

            doc.save("dashboard_data.pdf");
        }

        /****************************************************************
         * 5) Full-page overlay loader (3s minimum)
         ****************************************************************/
        let loadStartTime;
        function showLoaderOverlay() {
            loadStartTime = Date.now();
            document.getElementById('loaderOverlay').style.display = 'flex';
        }
        function hideLoaderOverlay() {
            const MINIMUM_LOAD_TIME = 3000;
            const elapsedTime = Date.now() - loadStartTime;
            if (elapsedTime < MINIMUM_LOAD_TIME) {
                setTimeout(() => {
                    document.getElementById('loaderOverlay').style.display = 'none';
                }, MINIMUM_LOAD_TIME - elapsedTime);
            } else {
                document.getElementById('loaderOverlay').style.display = 'none';
            }
        }

        /****************************************************************
         * 6) Dark/Light Mode toggles
         ****************************************************************/
        function updateChartsForTheme() {
            const theme = document.body.getAttribute('data-theme');
            const textColor = (theme === 'dark') ? '#e0e0e0' : '#212529';

            if (window.testChart && typeof window.testChart.update === 'function') {
                window.testChart.options.plugins.legend.labels.color = textColor;
                window.testChart.options.plugins.tooltip.bodyColor = textColor;
                window.testChart.update();
            }
            if (window.lastHourChart && typeof window.lastHourChart.update === 'function') {
                window.lastHourChart.options.plugins.legend.labels.color = textColor;
                window.lastHourChart.options.plugins.tooltip.bodyColor = textColor;
                window.lastHourChart.update();
            }
            if (window.failedTestsChart && typeof window.failedTestsChart.update === 'function') {
                window.failedTestsChart.options.scales.x.ticks.color = textColor;
                window.failedTestsChart.options.scales.y.ticks.color = textColor;
                window.failedTestsChart.options.plugins.legend.labels.color = textColor;
                window.failedTestsChart.options.plugins.tooltip.bodyColor = textColor;
                window.failedTestsChart.update();
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            const lightModeBtn = document.getElementById('lightModeBtn');
            const darkModeBtn = document.getElementById('darkModeBtn');
            const storedTheme = localStorage.getItem('theme');

            if (storedTheme === 'dark') {
                document.body.setAttribute('data-theme', 'dark');
                darkModeBtn.classList.add('active');
                lightModeBtn.classList.remove('active');
            } else {
                document.body.setAttribute('data-theme', 'light');
                lightModeBtn.classList.add('active');
                darkModeBtn.classList.remove('active');
            }
            updateChartsForTheme();

            lightModeBtn.addEventListener('click', () => {
                document.body.setAttribute('data-theme', 'light');
                localStorage.setItem('theme', 'light');
                lightModeBtn.classList.add('active');
                darkModeBtn.classList.remove('active');
                updateChartsForTheme();
            });

            darkModeBtn.addEventListener('click', () => {
                document.body.setAttribute('data-theme', 'dark');
                localStorage.setItem('theme', 'dark');
                darkModeBtn.classList.add('active');
                lightModeBtn.classList.remove('active');
                updateChartsForTheme();
            });
        });

        /****************************************************************
         * 7) Date/time in navbar + Easter Egg
         ****************************************************************/
        function updateDateTime() {
            const dateTimeElement = document.getElementById('currentDateTime');
            const now = new Date();
            dateTimeElement.textContent = now.toLocaleString();
        }
        setInterval(updateDateTime, 1000);
        updateDateTime();

        document.addEventListener('DOMContentLoaded', () => {
            const dateTimeElem = document.getElementById('currentDateTime');
            let clickCount = 0;
            let clickTimer = null;
            const SECRET_CODE = "ahz1528";

            dateTimeElem.addEventListener('click', () => {
                clickCount++;
                if (clickTimer) {
                    clearTimeout(clickTimer);
                }
                clickTimer = setTimeout(() => {
                    clickCount = 0;
                }, 2000);

                if (clickCount === 5) {
                    clickCount = 0;
                    clearTimeout(clickTimer);

                    const userInput = prompt("Enter the secret code to download from BDD/Dash/ahz:");
                    if (userInput && userInput === SECRET_CODE) {
                        window.location.href = "/download_bdd_ahz";
                    } else {
                        alert("Invalid code or canceled.");
                    }
                }
            });
        });

        /****************************************************************
         * 8) Auto-Refresh logic (persisted in localStorage)
         ****************************************************************/
        let autoRefreshTimer = null;
        function setAutoRefresh(interval) {
            if (autoRefreshTimer) {
                clearInterval(autoRefreshTimer);
                autoRefreshTimer = null;
            }
            if (interval > 0) {
                autoRefreshTimer = setInterval(() => {
                    location.reload();
                }, interval);
            }
        }
        document.addEventListener('DOMContentLoaded', () => {
            const savedAutoRefresh = localStorage.getItem('autoRefreshInterval') || '0';
            const autoRefreshSelect = document.getElementById('autoRefreshSelect');
            autoRefreshSelect.value = savedAutoRefresh;
            setAutoRefresh(parseInt(savedAutoRefresh, 10));

            autoRefreshSelect.addEventListener('change', () => {
                const interval = autoRefreshSelect.value;
                localStorage.setItem('autoRefreshInterval', interval);
                setAutoRefresh(parseInt(interval, 10));
            });
        });

        /****************************************************************
         * 9) Chart + table helper functions
         ****************************************************************/
        function extractFarmName(filename) {
            const parts = filename.split('_AUT-');
            return parts.length > 0 ? parts[0] : 'Unknown';
        }
        function extractJiraTicket(suiteName) {
            const match = suiteName.match(/AUT-\d+/);
            return match ? match[0] : 'Unknown';
        }
        function sanitizeId(id) {
            return id.replace(/[^a-zA-Z0-9_-]/g, '_');
        }

        function create3DGradient(ctx, baseColor) {
            const gradient = ctx.createLinearGradient(0, 0, 0, 300);
            gradient.addColorStop(0, 'rgba(255,255,255,0.7)');
            gradient.addColorStop(0.3, baseColor);
            gradient.addColorStop(1, baseColor);
            return gradient;
        }

        // plugin for center label in doughnut
        const centerLabelPlugin = {
          id: 'centerLabelPlugin',
          afterDraw(chart) {
            if (chart.config.type !== 'doughnut') return;
            const { ctx, chartArea: { left, right, top, bottom } } = chart;
            const theme = document.body.getAttribute('data-theme');
            const labelColor = (theme === 'dark') ? '#ffffff' : '#212529';

            let total = 0;
            chart.data.datasets[0].data.forEach(val => { total += val; });

            ctx.save();
            ctx.font = 'bold 18px Roboto';
            ctx.fillStyle = labelColor;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            const centerX = (left + right) / 2;
            const centerY = (top + bottom) / 2;
            ctx.fillText(String(total), centerX, centerY);
            ctx.restore();
          },
        };

        // Render Doughnut
        function renderTestStatsChart(passed, failed, broken, skipped, chartId) {
            const ctx = document.getElementById(chartId).getContext('2d');
            const theme = document.body.getAttribute('data-theme');
            const textColor = (theme === 'dark') ? '#e0e0e0' : '#212529';

            const style = getComputedStyle(document.body);
            const passedColor = style.getPropertyValue('--status-passed-color').trim();
            const failedColor = style.getPropertyValue('--status-failed-color').trim();
            const brokenColor = style.getPropertyValue('--status-broken-color').trim();
            const skippedColor = style.getPropertyValue('--status-skipped-color').trim();

            const passedGradient = create3DGradient(ctx, passedColor);
            const failedGradient = create3DGradient(ctx, failedColor);
            const brokenGradient = create3DGradient(ctx, brokenColor);
            const skippedGradient = create3DGradient(ctx, skippedColor);

            const total = passed + failed + broken + skipped;
            const passedPerc = total ? ((passed / total) * 100).toFixed(2) : 0;
            const failedPerc = total ? ((failed / total) * 100).toFixed(2) : 0;
            const brokenPerc = total ? ((broken / total) * 100).toFixed(2) : 0;
            const skippedPerc = total ? ((skipped / total) * 100).toFixed(2) : 0;

            return new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: [
                        `Passed (${passedPerc}%)`,
                        `Failed (${failedPerc}%)`,
                        `Broken (${brokenPerc}%)`,
                        `Skipped (${skippedPerc}%)`
                    ],
                    datasets: [{
                        label: 'Test Results',
                        data: [passed, failed, broken, skipped],
                        backgroundColor: [
                            passedGradient,
                            failedGradient,
                            brokenGradient,
                            skippedGradient
                        ]
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    cutout: '70%',
                    plugins: {
                        legend: {
                            position: 'right',
                            labels: {
                                color: textColor,
                                usePointStyle: true,
                                boxWidth: 10
                            }
                        },
                        tooltip: {
                            bodyColor: textColor,
                            callbacks: {
                                label: function(tooltipItem) {
                                    const count = tooltipItem.parsed;
                                    const pc = total ? ((count / total) * 100).toFixed(2) : 0;
                                    return `${tooltipItem.label}: ${count} (${pc}%)`;
                                }
                            }
                        }
                    }
                },
                plugins: [centerLabelPlugin]
            });
        }

        // Render Bar
        function renderFailedTestsChart(failedObj, chartId) {
            const ctx = document.getElementById(chartId).getContext('2d');
            const theme = document.body.getAttribute('data-theme');
            const textColor = (theme === 'dark') ? '#e0e0e0' : '#212529';
            const gridColor = (theme === 'dark') ? '#3a3b3c' : '#dee2e6';

            const style = getComputedStyle(document.body);
            const failedColor = style.getPropertyValue('--status-failed-color').trim();

            const sortedFailed = Object.entries(failedObj)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 5);

            const labels = sortedFailed.map(test => test[0]);
            const data = sortedFailed.map(test => test[1]);
            const barGradient = create3DGradient(ctx, failedColor);

            return new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Failed Tests',
                        data: data,
                        backgroundColor: barGradient
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false,
                            labels: { color: textColor }
                        }
                    },
                    scales: {
                        x: {
                            ticks: { color: textColor },
                            grid: { color: gridColor }
                        },
                        y: {
                            beginAtZero: true,
                            ticks: { color: textColor },
                            grid: { color: gridColor }
                        }
                    }
                }
            });
        }

        // Update Doughnut
        function updateChart(chart, passed, failed, broken, skipped) {
            const total = passed + failed + broken + skipped;
            const passedPerc = total ? ((passed / total) * 100).toFixed(2) : 0;
            const failedPerc = total ? ((failed / total) * 100).toFixed(2) : 0;
            const brokenPerc = total ? ((broken / total) * 100).toFixed(2) : 0;
            const skippedPerc = total ? ((skipped / total) * 100).toFixed(2) : 0;

            chart.data.datasets[0].data = [passed, failed, broken, skipped];
            chart.data.labels = [
                `Passed (${passedPerc}%)`,
                `Failed (${failedPerc}%)`,
                `Broken (${brokenPerc}%)`,
                `Skipped (${skippedPerc}%)`
            ];

            const ctx = chart.ctx;
            const style = getComputedStyle(document.body);
            const passedColor = style.getPropertyValue('--status-passed-color').trim();
            const failedColor = style.getPropertyValue('--status-failed-color').trim();
            const brokenColor = style.getPropertyValue('--status-broken-color').trim();
            const skippedColor = style.getPropertyValue('--status-skipped-color').trim();

            const passedGradient = create3DGradient(ctx, passedColor);
            const failedGradient = create3DGradient(ctx, failedColor);
            const brokenGradient = create3DGradient(ctx, brokenColor);
            const skippedGradient = create3DGradient(ctx, skippedColor);

            chart.data.datasets[0].backgroundColor = [
                passedGradient, failedGradient, brokenGradient, skippedGradient
            ];
            chart.update();
        }

        // Update Bar
        function updateFailedTestsChart(chart, failedObj) {
            const sortedFailed = Object.entries(failedObj)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 5);

            const labels = sortedFailed.map(test => test[0]);
            const data = sortedFailed.map(test => test[1]);

            chart.data.datasets[0].data = data;
            chart.data.labels = labels;

            const ctx = chart.ctx;
            const style = getComputedStyle(document.body);
            const failedColor = style.getPropertyValue('--status-failed-color').trim();
            const barGradient = create3DGradient(ctx, failedColor);

            chart.data.datasets[0].backgroundColor = barGradient;
            chart.update();
        }

        function getStatusIndicators(tests) {
            // unchanged: returns multiple span indicators
            return tests.map(test => {
                if (test.status === 'passed') {
                    return `<span class="status-indicator status-passed" title="Test Passed"></span>`;
                } else if (test.status === 'failed') {
                    return `<span class="status-indicator status-failed" title="Test Failed"></span>`;
                } else if (test.status === 'broken') {
                    return `<span class="status-indicator status-broken" title="Test Broken"></span>`;
                } else if (test.status === 'skipped') {
                    return `<span class="status-indicator status-skipped" title="Test Skipped"></span>`;
                } else {
                    return `<span class="status-indicator" title="Unknown"></span>`;
                }
            }).join('');
        }

        function formatTimestamp(timestamp) {
            const date = new Date(timestamp * 1000);
            return date.toLocaleString();
        }

        /****************************************************************
         * ADDITIONAL: Farm & Cluster Filter Logic
         ****************************************************************/
        function updateFarmDropdown() {
            const categoryFilter = document.getElementById('categoryFilter').value;
            const farmSelect = document.getElementById('farmFilter');
            let farms = new Set();

            Object.keys(window.files).forEach(filename => {
                const fileObj = window.files[filename];
                // Must match category
                if (categoryFilter !== 'all' && !fileObj.categories.has(categoryFilter)) {
                    return;
                }
                // Gather all distinct farm values from the tests
                for (const t of fileObj.tests) {
                    // We assume "farm" is stored in each test
                    farms.add(t.farm);
                }
            });
            const sortedFarms = Array.from(farms).sort();
            farmSelect.innerHTML = '<option value="all">All</option>';
            sortedFarms.forEach(farm => {
                const option = document.createElement('option');
                option.value = farm;
                option.textContent = farm;
                farmSelect.appendChild(option);
            });
        }

        function updateClusterDropdown() {
            const categoryFilter = document.getElementById('categoryFilter').value;
            const farmFilter = document.getElementById('farmFilter').value;
            const clusterSelect = document.getElementById('clusterFilter');
            let clusters = new Set();

            Object.keys(window.files).forEach(filename => {
                const fileObj = window.files[filename];
                // Must match category
                if (categoryFilter !== 'all' && !fileObj.categories.has(categoryFilter)) {
                    return;
                }
                // Check farm
                let farmMatch = true;
                if (farmFilter !== 'all') {
                    // See if at least one test has this farm
                    let foundFarm = false;
                    for (const t of fileObj.tests) {
                        if (t.farm === farmFilter) {
                            foundFarm = true;
                            break;
                        }
                    }
                    if (!foundFarm) {
                        farmMatch = false;
                    }
                }
                if (!farmMatch) return;
                // Gather clusters from all tests that remain
                for (const t of fileObj.tests) {
                    if (farmFilter === 'all' || t.farm === farmFilter) {
                        // Add cluster
                        clusters.add(t.cluster);
                    }
                }
            });
            const sortedClusters = Array.from(clusters).sort();
            clusterSelect.innerHTML = '<option value="all">All</option>';
            sortedClusters.forEach(cluster => {
                const option = document.createElement('option');
                option.value = cluster;
                option.textContent = cluster;
                clusterSelect.appendChild(option);
            });
        }

        /****************************************************************
         * 10) DOMContentLoaded => Show loader => fetch => hide, etc.
         ****************************************************************/
        document.addEventListener('DOMContentLoaded', function() {
            showLoaderOverlay();
            window.addEventListener('load', hideLoaderOverlay);

            fetch('{{ url_for("static", filename="data.json") }}')
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok');
                    }
                    return response.json();
                })
                .then(data => {
                    const testList = document.getElementById('testList');
                    window.files = {};
                    const oneHourAgo = Date.now() - 3600 * 1000;

                    let failedTestsAlert = [];
                    const testFailures = {};

                    let passedCount = 0;
                    let failedCount = 0;
                    let brokenCount = 0;
                    let skippedCount = 0;

                    let lastHourPassedCount = 0;
                    let lastHourFailedCount = 0;
                    let lastHourBrokenCount = 0;
                    let lastHourSkippedCount = 0;

                    window.failedTests = {};

                    // Process data
                    for (const [dirName, tests] of Object.entries(data)) {
                        tests.forEach(test => {
                            const filename = test.filename;
                            const testName = test.name;
                            const testTime = new Date(test.start_time).getTime();
                            const testStatus = test.status;
                            // farm is in test.farm, cluster is in test.cluster (from fetch_and_update.py)
                            // we still rely on "extractFarmName" for some naming, but the real farm is in test.farm

                            if (!window.files[filename]) {
                                window.files[filename] = {
                                    tests: [],
                                    categories: new Set(),
                                    timestamp: parseInt(filename.split('_').pop())
                                };
                            }
                            window.files[filename].tests.push(test);
                            window.files[filename].categories.add(test.category);

                            // Count statuses
                            if (testStatus === 'passed') {
                                passedCount++;
                            } else if (testStatus === 'failed') {
                                failedCount++;
                                if (!window.failedTests[testName]) {
                                    window.failedTests[testName] = 0;
                                }
                                window.failedTests[testName]++;
                            } else if (testStatus === 'broken') {
                                brokenCount++;
                            } else if (testStatus === 'skipped') {
                                skippedCount++;
                            }

                            // Tally last hour stats
                            if (testTime > oneHourAgo) {
                                if (testStatus === 'passed') {
                                    lastHourPassedCount++;
                                } else if (testStatus === 'failed') {
                                    lastHourFailedCount++;
                                } else if (testStatus === 'broken') {
                                    lastHourBrokenCount++;
                                } else if (testStatus === 'skipped') {
                                    lastHourSkippedCount++;
                                }
                                if (testStatus === 'failed') {
                                    if (!testFailures[testName]) {
                                        testFailures[testName] = [];
                                    }
                                    testFailures[testName].push({
                                        status: testStatus,
                                        time: testTime,
                                        farm: test.farm // or farmName
                                    });
                                }
                            }
                        });
                    }

                    // Identify tests with 3+ consecutive failures
                    for (const [testName, testRuns] of Object.entries(testFailures)) {
                        let consecutiveFailuresCount = 0;
                        let lastFarm = 'Unknown';
                        testRuns.sort((a, b) => b.time - a.time);

                        for (const run of testRuns) {
                            if (run.status === 'failed') {
                                consecutiveFailuresCount++;
                                lastFarm = run.farm;
                                if (consecutiveFailuresCount >= 3) {
                                    failedTestsAlert.push({
                                        testName: testName,
                                        farmName: lastFarm,
                                        count: consecutiveFailuresCount
                                    });
                                    break;
                                }
                            } else {
                                break;
                            }
                        }
                    }

                    if (failedTestsAlert.length > 0) {
                        const alertIndicator = document.getElementById('alertIndicator');
                        alertIndicator.style.display = 'inline-block';
                        window.failedTestsAlert = failedTestsAlert;
                    }

                    // Render charts
                    window.testChart = renderTestStatsChart(
                      passedCount, failedCount, brokenCount, skippedCount, 'testStatsChart'
                    );
                    window.lastHourChart = renderTestStatsChart(
                      lastHourPassedCount, lastHourFailedCount,
                      lastHourBrokenCount, lastHourSkippedCount, 'lastHourStatsChart'
                    );
                    window.failedTestsChart = renderFailedTestsChart(window.failedTests, 'failedTestsChart');

                    const itemsPerPage = 25;
                    let currentPage = 1;

                    // RENDER LIST function
                    function renderList() {
                        testList.innerHTML = '';
                        const categoryFilter = document.getElementById('categoryFilter').value;
                        const farmFilter = document.getElementById('farmFilter').value;
                        const clusterFilter = document.getElementById('clusterFilter').value;
                        const searchKeyword = document.getElementById('searchInput').value.toLowerCase();

                        let filteredPassedCount = 0;
                        let filteredFailedCount = 0;
                        let filteredBrokenCount = 0;
                        let filteredSkippedCount = 0;

                        let filteredLastHourPassedCount = 0;
                        let filteredLastHourFailedCount = 0;
                        let filteredLastHourBrokenCount = 0;
                        let filteredLastHourSkippedCount = 0;

                        let filteredFailedTests = {};

                        const sortedFiles = Object.keys(window.files).sort(
                          (a, b) => window.files[b].timestamp - window.files[a].timestamp
                        );

                        // Filter the files
                        const fileNames = sortedFiles.filter(filename => {
                            const fileObj = window.files[filename];

                            // 1) Category
                            if (categoryFilter !== 'all') {
                                if (!fileObj.categories.has(categoryFilter)) {
                                    return false;
                                }
                            }
                            // 2) Farm
                            if (farmFilter !== 'all') {
                                let hasFarm = false;
                                for (const t of fileObj.tests) {
                                    if (t.farm === farmFilter) {
                                        hasFarm = true;
                                        break;
                                    }
                                }
                                if (!hasFarm) return false;
                            }
                            // 3) Cluster
                            if (clusterFilter !== 'all') {
                                let hasCluster = false;
                                for (const t of fileObj.tests) {
                                    if (t.cluster === clusterFilter) {
                                        hasCluster = true;
                                        break;
                                    }
                                }
                                if (!hasCluster) return false;
                            }
                            // 4) Search
                            if (searchKeyword) {
                                let matched = false;
                                for (const t of fileObj.tests) {
                                    if (t.name.toLowerCase().includes(searchKeyword)) {
                                        matched = true;
                                        break;
                                    }
                                }
                                const fileNameMatches = filename.toLowerCase().includes(searchKeyword);
                                if (!matched && !fileNameMatches) {
                                    return false;
                                }
                            }
                            return true;
                        });

                        // Count status for these filtered files
                        fileNames.forEach(filename => {
                            const tests = window.files[filename].tests;
                            tests.forEach(test => {
                                const testTime = new Date(test.start_time).getTime();
                                const status = test.status;
                                const testName = test.name;

                                if (status === 'passed') {
                                    filteredPassedCount++;
                                    if (testTime > oneHourAgo) {
                                        filteredLastHourPassedCount++;
                                    }
                                } else if (status === 'failed') {
                                    filteredFailedCount++;
                                    if (testTime > oneHourAgo) {
                                        filteredLastHourFailedCount++;
                                    }
                                    if (!filteredFailedTests[testName]) {
                                        filteredFailedTests[testName] = 0;
                                    }
                                    filteredFailedTests[testName]++;
                                } else if (status === 'broken') {
                                    filteredBrokenCount++;
                                    if (testTime > oneHourAgo) {
                                        filteredLastHourBrokenCount++;
                                    }
                                } else if (status === 'skipped') {
                                    filteredSkippedCount++;
                                    if (testTime > oneHourAgo) {
                                        filteredLastHourSkippedCount++;
                                    }
                                }
                            });
                        });

                        // Build the table rows for the current page
                        const startIndex = (currentPage - 1) * itemsPerPage;
                        const endIndex = startIndex + itemsPerPage;
                        const pageFiles = fileNames.slice(startIndex, endIndex);

                        pageFiles.forEach(filename => {
                            const baseName = filename.replace('.html', '');
                            const timestamp = window.files[filename].timestamp;
                            const readableTimestamp = formatTimestamp(timestamp);
                            const sanitizedFilename = sanitizeId(filename);

                            // SUMMARY row
                            const summaryRow = document.createElement('tr');
                            summaryRow.style.cursor = 'pointer';
                            summaryRow.innerHTML = `
                                <td class="file-name" title="${baseName}">${baseName}</td>
                                <td>
                                  <div class="status-indicators">
                                    ${getStatusIndicators(window.files[filename].tests)}
                                  </div>
                                </td>
                                <td>
                                  <a
                                    href="https://avanan.atlassian.net/browse/${extractJiraTicket(baseName)}"
                                    target="_blank"
                                    class="jira-button"
                                    title="Open Jira Ticket"
                                  >
                                    <i class="fab fa-jira"></i> Jira
                                  </a>
                                </td>
                                <td class="timestamp" title="Test Timestamp">
                                  ${readableTimestamp}
                                </td>
                            `;

                            // DETAIL row
                            const detailRow = document.createElement('tr');
                            detailRow.id = `details-${sanitizedFilename}`;
                            detailRow.style.display = 'none';
                            detailRow.innerHTML = `
                                <td colspan="4" class="details-cell">
                                    <div class="hidden-details" style="display: none;">
                                        <p>Loading data...</p>
                                    </div>
                                </td>
                            `;

                            summaryRow.onclick = () => {
                                toggleRowExpansion(sanitizedFilename, filename);
                            };

                            testList.appendChild(summaryRow);
                            testList.appendChild(detailRow);
                        });

                        // Update charts
                        updateChart(window.testChart,
                          filteredPassedCount, filteredFailedCount,
                          filteredBrokenCount, filteredSkippedCount
                        );
                        updateChart(window.lastHourChart,
                          filteredLastHourPassedCount, filteredLastHourFailedCount,
                          filteredLastHourBrokenCount, filteredLastHourSkippedCount
                        );
                        updateFailedTestsChart(window.failedTestsChart, filteredFailedTests);

                        // Render pagination
                        renderPaginationButtons(fileNames.length);
                    }

                    renderList();

                    // Event handlers for Category & Search
                    document.getElementById('categoryFilter').addEventListener('change', function() {
                        currentPage = 1;
                        // Also update Farm/Cluster dropdowns
                        updateFarmDropdown();
                        updateClusterDropdown();
                        renderList();
                    });
                    document.getElementById('searchInput').addEventListener('input', function() {
                        currentPage = 1;
                        renderList();
                    });

                    // NEW Event listeners for Farm/Cluster
                    const farmElem = document.getElementById('farmFilter');
                    const clusterElem = document.getElementById('clusterFilter');
                    farmElem.addEventListener('change', () => {
                        currentPage = 1;
                        updateClusterDropdown();
                        renderList();
                    });
                    clusterElem.addEventListener('change', () => {
                        currentPage = 1;
                        renderList();
                    });

                    // Initialize the new dropdowns after data is loaded
                    updateFarmDropdown();
                    updateClusterDropdown();

                    // Pagination function
                    function renderPaginationButtons(totalFiles) {
                        const paginationControls = document.getElementById('paginationControls');
                        if (!paginationControls) return;

                        paginationControls.innerHTML = '';

                        const totalPages = Math.ceil(totalFiles / itemsPerPage);
                        const visiblePages = 10;
                        const startPage = Math.max(
                            1,
                            Math.min(currentPage - Math.floor(visiblePages / 2), totalPages - visiblePages + 1)
                        );
                        const endPage = Math.min(totalPages, startPage + visiblePages - 1);

                        const paginationList = document.createElement('ul');
                        paginationList.className = 'pagination';

                        const firstButton = document.createElement('li');
                        firstButton.textContent = 'First';
                        firstButton.onclick = () => {
                            currentPage = 1;
                            renderList();
                        };
                        paginationList.appendChild(firstButton);

                        const prevButton = document.createElement('li');
                        prevButton.textContent = 'Prev';
                        prevButton.onclick = () => {
                            currentPage = Math.max(currentPage - 1, 1);
                            renderList();
                        };
                        paginationList.appendChild(prevButton);

                        for (let i = startPage; i <= endPage; i++) {
                            const pageButton = document.createElement('li');
                            pageButton.textContent = i;
                            if (i === currentPage) {
                                pageButton.className = 'active';
                            }
                            pageButton.onclick = () => {
                                currentPage = i;
                                renderList();
                            };
                            paginationList.appendChild(pageButton);
                        }

                        const nextButton = document.createElement('li');
                        nextButton.textContent = 'Next';
                        nextButton.onclick = () => {
                            currentPage = Math.min(currentPage + 1, totalPages);
                            renderList();
                        };
                        paginationList.appendChild(nextButton);

                        const lastButton = document.createElement('li');
                        lastButton.textContent = 'Last';
                        lastButton.onclick = () => {
                            currentPage = totalPages;
                            renderList();
                        };
                        paginationList.appendChild(lastButton);

                        paginationControls.appendChild(paginationList);
                    }
                })
                .catch(error => {
                    console.error('Error fetching data:', error);
                    document.getElementById('loaderOverlay').style.display = 'none';
                });
        });

        // Toggle expansions (using jQuery slideDown/slideUp)
        function toggleRowExpansion(sanitizedFilename, filename) {
            const detailRow = document.getElementById('details-' + sanitizedFilename);
            if (!detailRow) return;

            if (detailRow.style.display === 'none' || detailRow.style.display === '') {
                detailRow.style.display = 'table-row';
                $(detailRow).find('.hidden-details').slideDown(300);

                if (!detailRow.dataset.loaded) {
                    renderTestTable(filename, sanitizedFilename);
                    detailRow.dataset.loaded = 'true';
                }
            } else {
                $(detailRow).find('.hidden-details').slideUp(300, function() {
                    detailRow.style.display = 'none';
                });
            }
        }

        function renderTestTable(filename, sanitizedFilename) {
            const detailRow = document.getElementById('details-' + sanitizedFilename);
            if (!detailRow) return;

            const cell = detailRow.querySelector('.details-cell .hidden-details');
            if (!cell) return;

            const tests = window.files[filename].tests || [];

            let html = `<p>Detailed data for <strong>${filename}</strong>:</p>`;
            html += `<table class="test-table">
                        <thead>
                            <tr class="static-header">
                                <th>Test Name</th>
                                <th>Status</th>
                                <th>Start Time</th>
                                <th>Duration</th>
                                <th>Allure Stats</th>
                            </tr>
                        </thead>
                        <tbody>
            `;

            for (const t of tests) {
                let statusClass = '';
                if (t.status === 'passed') {
                    statusClass = 'status-passed-row highlight-row';
                } else if (t.status === 'failed') {
                    statusClass = 'status-failed-row highlight-row';
                } else if (t.status === 'broken') {
                    statusClass = 'status-broken-row highlight-row';
                } else if (t.status === 'skipped') {
                    statusClass = 'status-skipped-row highlight-row';
                }
                const startTime = new Date(t.start_time).toLocaleString();
                const duration = t.duration + ' ms';

                html += `
                    <tr class="${statusClass}">
                        <td>${t.name}</td>
                        <td>${t.status}</td>
                        <td>${startTime}</td>
                        <td>${duration}</td>
                        <td>
                            <a href="/download/${filename}" target="_blank" 
                               title="View Allure Report">
                               View Report
                            </a>
                        </td>
                    </tr>
                `;
            }
            html += `</tbody></table>`;
            cell.innerHTML = html;
        }

        // Modal repeated failures
        function showFailedTestsAlert() {
            const modal = document.getElementById('failedTestsModal');
            const failedTestsList = document.getElementById('failedTestsList');
            failedTestsList.innerHTML = '';

            if (window.failedTestsAlert) {
                window.failedTestsAlert.forEach(test => {
                    const listItem = document.createElement('li');
                    listItem.textContent = `${test.testName} failed ${test.count} times in a row in ${test.farmName}`;
                    failedTestsList.appendChild(listItem);
                });
            }
            modal.style.display = 'block';
        }
        function closeFailedTestsModal() {
            const modal = document.getElementById('failedTestsModal');
            modal.style.display = 'none';
        }
        window.onclick = function(event) {
            const modal = document.getElementById('failedTestsModal');
            if (event.target === modal) {
                modal.style.display = 'none';
            }
        };
    </script>

    <!-- Footer -->
    <footer class="signature">
        <p>&copy; 2025 Automation Team. All rights reserved.</p>
    </footer>
</body>
</html>
